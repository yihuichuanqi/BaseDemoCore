// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: BDSpotComInst.proto

// This CPP symbol can be defined to use imports that match up to the framework
// imports needed when using CocoaPods.
#if !defined(GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS)
 #define GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS 0
#endif

#if GPB_USE_PROTOBUF_FRAMEWORK_IMPORTS
 #import <Protobuf/GPBProtocolBuffers_RuntimeSupport.h>
#else
 #import "GPBProtocolBuffers_RuntimeSupport.h"
#endif

 #import "BdspotComInst.pbobjc.h"
// @@protoc_insertion_point(imports)

#pragma clang diagnostic push
#pragma clang diagnostic ignored "-Wdeprecated-declarations"

#pragma mark - BdspotComInstRoot

@implementation BdspotComInstRoot

// No extensions in the file and no imports, so no need to generate
// +extensionRegistry.

@end

#pragma mark - BdspotComInstRoot_FileDescriptor

static GPBFileDescriptor *BdspotComInstRoot_FileDescriptor(void) {
  // This is called by +initialize so there is no need to worry
  // about thread safety of the singleton.
  static GPBFileDescriptor *descriptor = NULL;
  if (!descriptor) {
    GPB_DEBUG_CHECK_RUNTIME_VERSIONS();
    descriptor = [[GPBFileDescriptor alloc] initWithPackage:@""
                                                     syntax:GPBFileSyntaxProto3];
  }
  return descriptor;
}

#pragma mark - Enum MSG

GPBEnumDescriptor *MSG_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "MsgPlaceholder\000MsgRemoveCache\000MsgResetRe"
        "q\000MsgSetWill\000MsgSpotStatusChange\000MsgSpot"
        "InfoChange\000MsgReportSpotUpdateTime\000MsgRe"
        "sponseChatMessageChange\000MsgResponseRedDo"
        "tInfo\000MsgResponseOrderStatusChange\000MsgRe"
        "portUserLogout\000MsgConfigChange\000";
    static const int32_t values[] = {
        MSG_MsgPlaceholder,
        MSG_MsgRemoveCache,
        MSG_MsgResetReq,
        MSG_MsgSetWill,
        MSG_MsgSpotStatusChange,
        MSG_MsgSpotInfoChange,
        MSG_MsgReportSpotUpdateTime,
        MSG_MsgResponseChatMessageChange,
        MSG_MsgResponseRedDotInfo,
        MSG_MsgResponseOrderStatusChange,
        MSG_MsgReportUserLogout,
        MSG_MsgConfigChange,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(MSG)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:MSG_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL MSG_IsValidValue(int32_t value__) {
  switch (value__) {
    case MSG_MsgPlaceholder:
    case MSG_MsgRemoveCache:
    case MSG_MsgResetReq:
    case MSG_MsgSetWill:
    case MSG_MsgSpotStatusChange:
    case MSG_MsgSpotInfoChange:
    case MSG_MsgReportSpotUpdateTime:
    case MSG_MsgResponseChatMessageChange:
    case MSG_MsgResponseRedDotInfo:
    case MSG_MsgResponseOrderStatusChange:
    case MSG_MsgReportUserLogout:
    case MSG_MsgConfigChange:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Enum NOTICE

GPBEnumDescriptor *NOTICE_EnumDescriptor(void) {
  static GPBEnumDescriptor *descriptor = NULL;
  if (!descriptor) {
    static const char *valueNames =
        "NoticePlaceholder\000NoticeSystem\000NoticeFan"
        "s\000NoticeTimeline\000NoticeNewspot\000NoticeAtm"
        "e\000NoticeLetter\000NoticeSocial\000NoticeMessag"
        "eCenter\000";
    static const int32_t values[] = {
        NOTICE_NoticePlaceholder,
        NOTICE_NoticeSystem,
        NOTICE_NoticeFans,
        NOTICE_NoticeTimeline,
        NOTICE_NoticeNewspot,
        NOTICE_NoticeAtme,
        NOTICE_NoticeLetter,
        NOTICE_NoticeSocial,
        NOTICE_NoticeMessageCenter,
    };
    GPBEnumDescriptor *worker =
        [GPBEnumDescriptor allocDescriptorForName:GPBNSStringifySymbol(NOTICE)
                                       valueNames:valueNames
                                           values:values
                                            count:(uint32_t)(sizeof(values) / sizeof(int32_t))
                                     enumVerifier:NOTICE_IsValidValue];
    if (!OSAtomicCompareAndSwapPtrBarrier(nil, worker, (void * volatile *)&descriptor)) {
      [worker release];
    }
  }
  return descriptor;
}

BOOL NOTICE_IsValidValue(int32_t value__) {
  switch (value__) {
    case NOTICE_NoticePlaceholder:
    case NOTICE_NoticeSystem:
    case NOTICE_NoticeFans:
    case NOTICE_NoticeTimeline:
    case NOTICE_NoticeNewspot:
    case NOTICE_NoticeAtme:
    case NOTICE_NoticeLetter:
    case NOTICE_NoticeSocial:
    case NOTICE_NoticeMessageCenter:
      return YES;
    default:
      return NO;
  }
}

#pragma mark - Base

@implementation Base

@dynamic cmd;
@dynamic timestamp;
@dynamic devId;
@dynamic payload;

typedef struct Base__storage_ {
  uint32_t _has_storage_[1];
  int32_t cmd;
  int32_t timestamp;
  NSString *devId;
  NSData *payload;
} Base__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "cmd",
        .dataTypeSpecific.className = NULL,
        .number = Base_FieldNumber_Cmd,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(Base__storage_, cmd),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "timestamp",
        .dataTypeSpecific.className = NULL,
        .number = Base_FieldNumber_Timestamp,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(Base__storage_, timestamp),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "devId",
        .dataTypeSpecific.className = NULL,
        .number = Base_FieldNumber_DevId,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(Base__storage_, devId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "payload",
        .dataTypeSpecific.className = NULL,
        .number = Base_FieldNumber_Payload,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(Base__storage_, payload),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeBytes,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[Base class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(Base__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\003\005\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpotStatusChange

@implementation SpotStatusChange

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct SpotStatusChange__storage_ {
  uint32_t _has_storage_[1];
  SpotStatusChange_Request *req;
  SpotStatusChange_Confirm *conf;
} SpotStatusChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(SpotStatusChange_Request),
        .number = SpotStatusChange_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpotStatusChange__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(SpotStatusChange_Confirm),
        .number = SpotStatusChange_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpotStatusChange__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpotStatusChange class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpotStatusChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpotStatusChange_Request

@implementation SpotStatusChange_Request

@dynamic spotId;
@dynamic status;
@dynamic updateTime;

typedef struct SpotStatusChange_Request__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
  int32_t updateTime;
  int64_t spotId;
} SpotStatusChange_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "spotId",
        .dataTypeSpecific.className = NULL,
        .number = SpotStatusChange_Request_FieldNumber_SpotId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpotStatusChange_Request__storage_, spotId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = SpotStatusChange_Request_FieldNumber_Status,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpotStatusChange_Request__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = SpotStatusChange_Request_FieldNumber_UpdateTime,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(SpotStatusChange_Request__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpotStatusChange_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpotStatusChange_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\002\001\006\000\003\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SpotStatusChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpotStatusChange_Confirm

@implementation SpotStatusChange_Confirm

@dynamic status;

typedef struct SpotStatusChange_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} SpotStatusChange_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = SpotStatusChange_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpotStatusChange_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpotStatusChange_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpotStatusChange_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SpotStatusChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpotInfoChange

@implementation SpotInfoChange

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct SpotInfoChange__storage_ {
  uint32_t _has_storage_[1];
  SpotInfoChange_Request *req;
  SpotInfoChange_Confirm *conf;
} SpotInfoChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(SpotInfoChange_Request),
        .number = SpotInfoChange_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpotInfoChange__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(SpotInfoChange_Confirm),
        .number = SpotInfoChange_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SpotInfoChange__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpotInfoChange class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpotInfoChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpotInfoChange_Request

@implementation SpotInfoChange_Request


typedef struct SpotInfoChange_Request__storage_ {
  uint32_t _has_storage_[1];
} SpotInfoChange_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpotInfoChange_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(SpotInfoChange_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SpotInfoChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SpotInfoChange_Confirm

@implementation SpotInfoChange_Confirm

@dynamic status;

typedef struct SpotInfoChange_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} SpotInfoChange_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = SpotInfoChange_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SpotInfoChange_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SpotInfoChange_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SpotInfoChange_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SpotInfoChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseChatMessage

@implementation ResponseChatMessage

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct ResponseChatMessage__storage_ {
  uint32_t _has_storage_[1];
  ResponseChatMessage_Request *req;
  ResponseChatMessage_Confirm *conf;
} ResponseChatMessage__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseChatMessage_Request),
        .number = ResponseChatMessage_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseChatMessage__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseChatMessage_Confirm),
        .number = ResponseChatMessage_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseChatMessage__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseChatMessage class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseChatMessage__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseChatMessage_Request

@implementation ResponseChatMessage_Request

@dynamic chatNum;

typedef struct ResponseChatMessage_Request__storage_ {
  uint32_t _has_storage_[1];
  int32_t chatNum;
} ResponseChatMessage_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "chatNum",
        .dataTypeSpecific.className = NULL,
        .number = ResponseChatMessage_Request_FieldNumber_ChatNum,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseChatMessage_Request__storage_, chatNum),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseChatMessage_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseChatMessage_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResponseChatMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseChatMessage_Confirm

@implementation ResponseChatMessage_Confirm

@dynamic status;

typedef struct ResponseChatMessage_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} ResponseChatMessage_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ResponseChatMessage_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseChatMessage_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseChatMessage_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseChatMessage_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResponseChatMessage)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseOrderStatusChange

@implementation ResponseOrderStatusChange

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct ResponseOrderStatusChange__storage_ {
  uint32_t _has_storage_[1];
  ResponseOrderStatusChange_Request *req;
  ResponseOrderStatusChange_Confirm *conf;
} ResponseOrderStatusChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseOrderStatusChange_Request),
        .number = ResponseOrderStatusChange_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseOrderStatusChange__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseOrderStatusChange_Confirm),
        .number = ResponseOrderStatusChange_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseOrderStatusChange__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseOrderStatusChange class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseOrderStatusChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseOrderStatusChange_Request

@implementation ResponseOrderStatusChange_Request

@dynamic orderId;

typedef struct ResponseOrderStatusChange_Request__storage_ {
  uint32_t _has_storage_[1];
  int64_t orderId;
} ResponseOrderStatusChange_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "orderId",
        .dataTypeSpecific.className = NULL,
        .number = ResponseOrderStatusChange_Request_FieldNumber_OrderId,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseOrderStatusChange_Request__storage_, orderId),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseOrderStatusChange_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseOrderStatusChange_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResponseOrderStatusChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseOrderStatusChange_Confirm

@implementation ResponseOrderStatusChange_Confirm

@dynamic status;

typedef struct ResponseOrderStatusChange_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} ResponseOrderStatusChange_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ResponseOrderStatusChange_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseOrderStatusChange_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseOrderStatusChange_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseOrderStatusChange_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResponseOrderStatusChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RedDotInfo

@implementation RedDotInfo

@dynamic type;
@dynamic num;

typedef struct RedDotInfo__storage_ {
  uint32_t _has_storage_[1];
  NOTICE type;
  int32_t num;
} RedDotInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "type",
        .dataTypeSpecific.enumDescFunc = NOTICE_EnumDescriptor,
        .number = RedDotInfo_FieldNumber_Type,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RedDotInfo__storage_, type),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldHasEnumDescriptor),
        .dataType = GPBDataTypeEnum,
      },
      {
        .name = "num",
        .dataTypeSpecific.className = NULL,
        .number = RedDotInfo_FieldNumber_Num,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RedDotInfo__storage_, num),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RedDotInfo class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RedDotInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

int32_t RedDotInfo_Type_RawValue(RedDotInfo *message) {
  GPBDescriptor *descriptor = [RedDotInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedDotInfo_FieldNumber_Type];
  return GPBGetMessageInt32Field(message, field);
}

void SetRedDotInfo_Type_RawValue(RedDotInfo *message, int32_t value) {
  GPBDescriptor *descriptor = [RedDotInfo descriptor];
  GPBFieldDescriptor *field = [descriptor fieldWithNumber:RedDotInfo_FieldNumber_Type];
  GPBSetInt32IvarWithFieldInternal(message, field, value, descriptor.file.syntax);
}

#pragma mark - ResponseRedDotInfo

@implementation ResponseRedDotInfo

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct ResponseRedDotInfo__storage_ {
  uint32_t _has_storage_[1];
  ResponseRedDotInfo_Request *req;
  ResponseRedDotInfo_Confirm *conf;
} ResponseRedDotInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseRedDotInfo_Request),
        .number = ResponseRedDotInfo_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseRedDotInfo__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(ResponseRedDotInfo_Confirm),
        .number = ResponseRedDotInfo_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResponseRedDotInfo__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseRedDotInfo class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseRedDotInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseRedDotInfo_Request

@implementation ResponseRedDotInfo_Request

@dynamic hasRedDotInfo, redDotInfo;

typedef struct ResponseRedDotInfo_Request__storage_ {
  uint32_t _has_storage_[1];
  RedDotInfo *redDotInfo;
} ResponseRedDotInfo_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "redDotInfo",
        .dataTypeSpecific.className = GPBStringifySymbol(RedDotInfo),
        .number = ResponseRedDotInfo_Request_FieldNumber_RedDotInfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseRedDotInfo_Request__storage_, redDotInfo),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseRedDotInfo_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseRedDotInfo_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResponseRedDotInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResponseRedDotInfo_Confirm

@implementation ResponseRedDotInfo_Confirm

@dynamic status;

typedef struct ResponseRedDotInfo_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} ResponseRedDotInfo_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ResponseRedDotInfo_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResponseRedDotInfo_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResponseRedDotInfo_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResponseRedDotInfo_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResponseRedDotInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveCache

@implementation RemoveCache

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct RemoveCache__storage_ {
  uint32_t _has_storage_[1];
  RemoveCache_Request *req;
  RemoveCache_Confirm *conf;
} RemoveCache__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(RemoveCache_Request),
        .number = RemoveCache_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveCache__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(RemoveCache_Confirm),
        .number = RemoveCache_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(RemoveCache__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveCache class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveCache__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveCache_Request

@implementation RemoveCache_Request


typedef struct RemoveCache_Request__storage_ {
  uint32_t _has_storage_[1];
} RemoveCache_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveCache_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(RemoveCache_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RemoveCache)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - RemoveCache_Confirm

@implementation RemoveCache_Confirm

@dynamic status;

typedef struct RemoveCache_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} RemoveCache_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = RemoveCache_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(RemoveCache_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[RemoveCache_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(RemoveCache_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(RemoveCache)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetReq

@implementation ResetReq

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct ResetReq__storage_ {
  uint32_t _has_storage_[1];
  ResetReq_Request *req;
  ResetReq_Confirm *conf;
} ResetReq__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(ResetReq_Request),
        .number = ResetReq_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResetReq__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(ResetReq_Confirm),
        .number = ResetReq_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ResetReq__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetReq class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResetReq__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetReq_Request

@implementation ResetReq_Request


typedef struct ResetReq_Request__storage_ {
  uint32_t _has_storage_[1];
} ResetReq_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetReq_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ResetReq_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResetReq)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ResetReq_Confirm

@implementation ResetReq_Confirm

@dynamic status;

typedef struct ResetReq_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} ResetReq_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ResetReq_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ResetReq_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ResetReq_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ResetReq_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ResetReq)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfigChange

@implementation ConfigChange

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct ConfigChange__storage_ {
  uint32_t _has_storage_[1];
  ConfigChange_Request *req;
  ConfigChange_Confirm *conf;
} ConfigChange__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(ConfigChange_Request),
        .number = ConfigChange_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfigChange__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(ConfigChange_Confirm),
        .number = ConfigChange_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ConfigChange__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfigChange class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfigChange__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfigChange_Request

@implementation ConfigChange_Request


typedef struct ConfigChange_Request__storage_ {
  uint32_t _has_storage_[1];
} ConfigChange_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfigChange_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(ConfigChange_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ConfigChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ConfigChange_Confirm

@implementation ConfigChange_Confirm

@dynamic status;

typedef struct ConfigChange_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} ConfigChange_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ConfigChange_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ConfigChange_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ConfigChange_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ConfigChange_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ConfigChange)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetWill

@implementation SetWill

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct SetWill__storage_ {
  uint32_t _has_storage_[1];
  SetWill_Request *req;
  SetWill_Confirm *conf;
} SetWill__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(SetWill_Request),
        .number = SetWill_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetWill__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(SetWill_Confirm),
        .number = SetWill_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(SetWill__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetWill class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetWill__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetWill_Request

@implementation SetWill_Request


typedef struct SetWill_Request__storage_ {
  uint32_t _has_storage_[1];
} SetWill_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetWill_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:NULL
                                    fieldCount:0
                                   storageSize:sizeof(SetWill_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SetWill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - SetWill_Confirm

@implementation SetWill_Confirm

@dynamic status;

typedef struct SetWill_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} SetWill_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = SetWill_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(SetWill_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[SetWill_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(SetWill_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(SetWill)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReportSpotUpdateTime

@implementation ReportSpotUpdateTime

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct ReportSpotUpdateTime__storage_ {
  uint32_t _has_storage_[1];
  ReportSpotUpdateTime_Request *req;
  ReportSpotUpdateTime_Confirm *conf;
} ReportSpotUpdateTime__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(ReportSpotUpdateTime_Request),
        .number = ReportSpotUpdateTime_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(ReportSpotUpdateTime_Confirm),
        .number = ReportSpotUpdateTime_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReportSpotUpdateTime class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReportSpotUpdateTime__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReportSpotUpdateTime_Request

@implementation ReportSpotUpdateTime_Request

@dynamic updateTime;

typedef struct ReportSpotUpdateTime_Request__storage_ {
  uint32_t _has_storage_[1];
  int32_t updateTime;
} ReportSpotUpdateTime_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = ReportSpotUpdateTime_Request_FieldNumber_UpdateTime,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime_Request__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReportSpotUpdateTime_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReportSpotUpdateTime_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\001\001\n\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ReportSpotUpdateTime)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReportSpotUpdateTime_Confirm

@implementation ReportSpotUpdateTime_Confirm

@dynamic URL;
@dynamic packages;
@dynamic sign;
@dynamic updateTime;
@dynamic isFirst;

typedef struct ReportSpotUpdateTime_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t updateTime;
  int32_t isFirst;
  NSString *URL;
  NSString *packages;
  NSString *sign;
} ReportSpotUpdateTime_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "URL",
        .dataTypeSpecific.className = NULL,
        .number = ReportSpotUpdateTime_Confirm_FieldNumber_URL,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime_Confirm__storage_, URL),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeString,
      },
      {
        .name = "packages",
        .dataTypeSpecific.className = NULL,
        .number = ReportSpotUpdateTime_Confirm_FieldNumber_Packages,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime_Confirm__storage_, packages),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "sign",
        .dataTypeSpecific.className = NULL,
        .number = ReportSpotUpdateTime_Confirm_FieldNumber_Sign,
        .hasIndex = 2,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime_Confirm__storage_, sign),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeString,
      },
      {
        .name = "updateTime",
        .dataTypeSpecific.className = NULL,
        .number = ReportSpotUpdateTime_Confirm_FieldNumber_UpdateTime,
        .hasIndex = 3,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime_Confirm__storage_, updateTime),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
      {
        .name = "isFirst",
        .dataTypeSpecific.className = NULL,
        .number = ReportSpotUpdateTime_Confirm_FieldNumber_IsFirst,
        .hasIndex = 4,
        .offset = (uint32_t)offsetof(ReportSpotUpdateTime_Confirm__storage_, isFirst),
        .flags = (GPBFieldFlags)(GPBFieldOptional | GPBFieldTextFormatNameCustom),
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReportSpotUpdateTime_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReportSpotUpdateTime_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
#if !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    static const char *extraTextFormatInfo =
        "\003\001!!!\000\004\n\000\005\007\000";
    [localDescriptor setupExtraTextInfo:extraTextFormatInfo];
#endif  // !GPBOBJC_SKIP_MESSAGE_TEXTFORMAT_EXTRAS
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ReportSpotUpdateTime)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - UserInfo

@implementation UserInfo

@dynamic uid;

typedef struct UserInfo__storage_ {
  uint32_t _has_storage_[1];
  int64_t uid;
} UserInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "uid",
        .dataTypeSpecific.className = NULL,
        .number = UserInfo_FieldNumber_Uid,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(UserInfo__storage_, uid),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt64,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[UserInfo class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(UserInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReportDevInfo

@implementation ReportDevInfo

@dynamic hasReq, req;
@dynamic hasConf, conf;

typedef struct ReportDevInfo__storage_ {
  uint32_t _has_storage_[1];
  ReportDevInfo_Request *req;
  ReportDevInfo_Confirm *conf;
} ReportDevInfo__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "req",
        .dataTypeSpecific.className = GPBStringifySymbol(ReportDevInfo_Request),
        .number = ReportDevInfo_FieldNumber_Req,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReportDevInfo__storage_, req),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
      {
        .name = "conf",
        .dataTypeSpecific.className = GPBStringifySymbol(ReportDevInfo_Confirm),
        .number = ReportDevInfo_FieldNumber_Conf,
        .hasIndex = 1,
        .offset = (uint32_t)offsetof(ReportDevInfo__storage_, conf),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReportDevInfo class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReportDevInfo__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReportDevInfo_Request

@implementation ReportDevInfo_Request

@dynamic hasUserinfo, userinfo;

typedef struct ReportDevInfo_Request__storage_ {
  uint32_t _has_storage_[1];
  UserInfo *userinfo;
} ReportDevInfo_Request__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "userinfo",
        .dataTypeSpecific.className = GPBStringifySymbol(UserInfo),
        .number = ReportDevInfo_Request_FieldNumber_Userinfo,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReportDevInfo_Request__storage_, userinfo),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeMessage,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReportDevInfo_Request class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReportDevInfo_Request__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ReportDevInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end

#pragma mark - ReportDevInfo_Confirm

@implementation ReportDevInfo_Confirm

@dynamic status;

typedef struct ReportDevInfo_Confirm__storage_ {
  uint32_t _has_storage_[1];
  int32_t status;
} ReportDevInfo_Confirm__storage_;

// This method is threadsafe because it is initially called
// in +initialize for each subclass.
+ (GPBDescriptor *)descriptor {
  static GPBDescriptor *descriptor = nil;
  if (!descriptor) {
    static GPBMessageFieldDescription fields[] = {
      {
        .name = "status",
        .dataTypeSpecific.className = NULL,
        .number = ReportDevInfo_Confirm_FieldNumber_Status,
        .hasIndex = 0,
        .offset = (uint32_t)offsetof(ReportDevInfo_Confirm__storage_, status),
        .flags = GPBFieldOptional,
        .dataType = GPBDataTypeInt32,
      },
    };
    GPBDescriptor *localDescriptor =
        [GPBDescriptor allocDescriptorForClass:[ReportDevInfo_Confirm class]
                                     rootClass:[BdspotComInstRoot class]
                                          file:BdspotComInstRoot_FileDescriptor()
                                        fields:fields
                                    fieldCount:(uint32_t)(sizeof(fields) / sizeof(GPBMessageFieldDescription))
                                   storageSize:sizeof(ReportDevInfo_Confirm__storage_)
                                         flags:GPBDescriptorInitializationFlag_None];
    [localDescriptor setupContainingMessageClassName:GPBStringifySymbol(ReportDevInfo)];
    NSAssert(descriptor == nil, @"Startup recursed!");
    descriptor = localDescriptor;
  }
  return descriptor;
}

@end


#pragma clang diagnostic pop

// @@protoc_insertion_point(global_scope)
